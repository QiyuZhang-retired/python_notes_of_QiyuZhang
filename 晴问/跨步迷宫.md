# 跨步迷宫
**算法核心：广度优先搜索**  
迷宫问题的基础上加上一个跨步条件
```python
from collections import deque

def bfs(maze,n,m):
    in_queue=set()
    q=deque()
    in_queue.add((1,1))
    q.append((0,1,1))
    
    while q:
        front=q.popleft()
        if front[1:]==(n,m):
            return front[0]

        for dx,dy in ((-1,0),(1,0),(0,-1),(0,1)):
            nx=front[1]+dx
            ny=front[2]+dy
            if (nx,ny) not in in_queue and maze[nx][ny]==0:
                in_queue.add((nx,ny))
                q.append((front[0]+1,nx,ny))

        for dx2,dx1,dy1,dy2 in ((-2,-1,0,0),(2,1,0,0),(0,0,-1,-2),(0,0,1,2)):
            nx1=front[1]+dx1
            ny1=front[2]+dy1
            nx2=front[1]+dx2
            ny2=front[2]+dy2
            if (nx2,ny2) not in in_queue and maze[nx1][ny1]==0 and maze[nx2][ny2]==0:
                in_queue.add((nx2,ny2))
                q.append((front[0]+1,nx2,ny2))

    return -1

n,m=map(int,input().split())
maze=[[1]*(m+2)]
for _ in range(n):
    maze.append([1]+list(map(int,input().split()))+[1])
maze+=[[1]*(m+2)]

print(bfs(maze,n,m))
```
https://sunnywhy.com/sfbj/8/2/322
