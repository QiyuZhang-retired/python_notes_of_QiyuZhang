# 多终点迷宫问题
**核心算法：广度优先搜索**  
每次入队出队就记录一个位置的最小步数，最后没有元素自然结束循环
```python
from collections import deque

def bfs(maze,n,m):
    in_queue=set()
    q=deque()
    in_queue.add((1,1))
    q.append((0,1,1))

    while q:
        front=q.popleft()
        output[front[1]-1][front[2]-1]=front[0]

        for dx,dy in ((-1,0),(1,0),(0,-1),(0,1)):
            nx=front[1]+dx
            ny=front[2]+dy
            if (nx,ny) not in in_queue and maze[nx][ny]==0:
                in_queue.add((nx,ny))
                q.append((front[0]+1,nx,ny))

    return

n,m=map(int,input().split())
maze=[[1]*(m+2)]
for _ in range(n):
    maze.append([1]+list(map(int,input().split()))+[1])
maze+=[[1]*(m+2)]

output=[[-1]*m for _ in range(n)]
bfs(maze,n,m)

for row in output:
    print(' '.join(list(map(str,row))))
```
https://sunnywhy.com/sfbj/8/2/324
