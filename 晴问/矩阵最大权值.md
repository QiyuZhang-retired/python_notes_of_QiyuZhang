# 矩阵最大权值 
**核心算法：深度优先搜索**  
1）记录每一条路径的和，然后使用global与全局变量比较取最大  
2）标记了最后一处，要最后加上此处的值
```python
def dfs(x,y,summary):
    global max_summary

    for dx,dy in ((-1,0),(1,0),(0,-1),(0,1)):
        nx=x+dx
        ny=y+dy

        if maze[nx][ny]=='end':
            max_summary=max(max_summary,summary)
        else:
            if not visited[nx][ny]:
                visited[nx][ny]=True
                dfs(nx,ny,summary+maze[nx][ny])
                visited[nx][ny]=False

    return


n,m=map(int,input().split())
maze=[]
maze.append([1]*(m+2))
for _ in range(n):
    maze.append([1]+list(map(int,input().split()))+[1])
maze.append([1]*(m+2))

end_num=maze[n][m]
maze[n][m]='end'

#生成visited鼠标来标记是否到达
visited=[[True]*(m+2)]+[[True]+[False]*m+[True] for _ in range(n)]+[[True]*(m+2)]
visited[1][1]=True
max_summary=float('-inf')
dfs(1,1,maze[1][1])
print(max_summary+end_num)
```
https://sunnywhy.com/sfbj/8/1/315
