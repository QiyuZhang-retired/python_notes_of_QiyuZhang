# 迷宫问题
**算法核心：广度优先搜索**  
注意如果无解输出-1
```python
from collections import deque

def bfs(maze,n,m):
    in_queue=set()
    q=deque()
    in_queue.add((1,1))
    q.append((0,1,1))

    while q:
        front=q.popleft()
        if front[1:]==(n,m):
            return front[0]

        for dx,dy in ((-1,0),(1,0),(0,-1),(0,1)):
            nx=front[1]+dx
            ny=front[2]+dy
            if (nx,ny) not in in_queue and maze[nx][ny]==0:
                in_queue.add((nx,ny))
                q.append((front[0]+1,nx,ny))

    return -1

n,m=map(int,input().split())
maze=[[1]*(m+2)]
for _ in range(n):
    maze.append([1]+list(map(int,input().split()))+[1])
maze+=[[1]*(m+2)]

print(bfs(maze,n,m))
```
https://sunnywhy.com/sfbj/8/2/320
