# 矩阵中的块
**算法核心：深度优先搜索，广度优先搜索（连通域）**  
dfs和bfs对此题效果相似，但使用bfs写更稳定，相比dfs不易递归栈溢出（此处仅有bfs写法）
```python
from collections import deque

def bfs(x,y):
    q=deque()
    q.append((x,y))
    in_queue.add((x,y))

    while q:
        front=q.popleft()
        for dx,dy in ((-1,0),(1,0),(0,-1),(0,1)):
            nx=front[0]+dx
            ny=front[1]+dy
            if matrix[nx][ny]==1 and (nx,ny) not in in_queue:
                in_queue.add((nx,ny))
                q.append((nx,ny))

n,m=map(int,input().split())
matrix=[[0]*(m+2)]
for _ in range(n):
    matrix.append([0]+list(map(int,input().split()))+[0])
matrix.append([0]*(m+2))
in_queue=set()

cnt=0
for i in range(1,n+1):
    for j in range(1,m+1):
        if matrix[i][j]==1 and (i,j) not in in_queue:
            bfs(i,j)
            cnt+=1

print(cnt)
```
https://sunnywhy.com/sfbj/8/2/319
