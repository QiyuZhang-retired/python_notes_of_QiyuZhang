# 中国象棋-马-有障碍
**算法核心：广度优先搜索**  
在无障碍的基础上加上附加条件即可（obstacles）
```python
from collections import deque

def bfs(board,x,y):
    in_queue=set()
    q=deque()
    in_queue.add((x+1,y+1))
    q.append((0,x+1,y+1))

    while q:
        front=q.popleft()
        board[front[1]][front[2]]=front[0]

        for dx,dy,a,b in ((-2,-1,-1,0),(-2,1,-1,0),(-1,-2,0,-1),(-1,2,0,1),(1,-2,0,-1),(1,2,0,1),(2,-1,1,0),(2,1,1,0)):
            nx=front[1]+dx
            ny=front[2]+dy
            xa=front[1]+a
            yb=front[2]+b
            if (nx,ny) not in in_queue and board[nx][ny]!=float('-inf') and (nx,ny) not in obstacles and (xa,yb) not in obstacles:
                in_queue.add((nx,ny))
                q.append((front[0]+1,nx,ny))

    return

n,m,x,y=map(int,input().split())
board=[[float('-inf')]*(m+4),[float('-inf')]*(m+4)]
for _ in range(n):
    board.append([float('-inf')]*2+[-1]*m+[float('-inf')]*2)
board+=[[float('-inf')]*(m+4),[float('-inf')]*(m+4)]

obstacles=[]
k=int(input())
for _ in range(k):
    xi,yi=map(int,input().split())
    obstacles.append((xi+1,yi+1))

bfs(board,x,y)

for row in board[2:-2]:
    print(' '.join(list(map(str,row[2:-2]))))
```
https://sunnywhy.com/sfbj/8/2/327
