# M23421:《算法图解》小偷背包问题
**核心算法：动态规划（0-1背包）**  
方法一：  
1）状态转移函数：dp表示一个表格，横坐标是背包承载的最大重量，纵坐标是各个物品的价值，dp表示在此承重下，选取这个位置之前的物品时的最大价值  
2）状态转移关系：有两种选法，一个是选取当前位置的物品，那么就再用剩下质量选择；一个是不选取当前位置的物品，那么就是上一行的值。在这两种选法中取较大值即可，注意要先判断背包能否装下物品    
3）在填充表格时为了处理边界条件，在表格外套了保护圈
```python
N, B=map(int,input().split())
values=list(map(int,input().split()))
weights=list(map(int,input().split()))

#设置dp数组
dp=[[0]*(B+1) for _ in range(N+1)]

#根据状态转移函数填充表格
for i in range(1,N+1):
    for j in range(1,B+1):
        if j>=weights[i-1]:
            dp[i][j]=max(dp[i-1][j],values[i-1]+dp[i-1][j-weights[i-1]])
        else:
            dp[i][j]=dp[i-1][j]

print(dp[N][B])
```
方法二：  
1）用滚动数组来降维优化空间复杂度，将dp设置为放入前i个物品后的不同承重的最大价值（去除了第一维）  
2）要注意从后往前遍历更新dp，保证更新时前面的数还是上一个状态的数，满足01背包的条件
```python
N,B=map(int,input().split())
values=list(map(int,input().split()))
weights=list(map(int,input().split()))

#设置滚动数组函数
dp=[0]*(B+1)

#进行状态转移
for i in range(N):
    for j in range(B,weights[i]-1,-1):
        dp[j]=max(dp[j],dp[j-weights[i]]+values[i])

print(dp[-1])
```
http://cs101.openjudge.cn/pctbook/M23421/
